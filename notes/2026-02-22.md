So there exists the Valed project and there exists the Python demo and the developer book in the Valed chat. And then we have our own command line tool of Vetricore that we're working on. Spelled Vetchricore
the voice to text might type it a different way.So we've kind of adopted the command line structure of the Python stuff just as a demo, and it wasn't quite working, but we want tocreate our own thing from scratch here where we're trying to build an app that's going to replace sync play.And...the functionality that we want from it is going to include some hierarchies and some elements like friends.But because we want to be able to test it locally without having to join a different machine, we're also going to need to add a profiles feature such that we can run the command line from different profiles.like with a dash dash profile argument as kind of a global argument todo different things.

So we should probably create a profile add profile list profileuse command.

We're basically going to get rid of the existing command structure and replace it with a new one.

The Timi Rust CLI has some examples on how we do the nested command stuff, but basically we want each subcommand to be its own module rather than stuffing everything in one file. We want to split it out into different files so that it's not just one huge thing.



```
vetchricore.exe profile list
> main (active)
> profile2
> profile3
vetchricore.exe profile use profile2
> Now using profile2.
vetchricore.exe profile remove profile3
> Profile3 has been destroyed.
```

global args has a `--profile {profilename}` argument

all other configuration is rooted in the profile so we can immitate multiple clients on a single machine

```
vetchricore.exe profile show
> You are using profile2.
vetchricore.exe friend list
> You have no friends. A new dawn awaits.
vetchricore.exe friend add jeff VLD0:12345
> You have added jeff as a friend.
vetchricore.exe friend rename jeff joe
> jeff has been renamed to joe.
vetchricore.exe friend remove joe
> Joe has been unfriended.
vetchricore.exe friend add danny VLD0:5342132
> You have added danny as a friend.
vetchricore.exe profile use main
> Now using main.
vetchricore.exe friend list
> You have no friends. A new dawn awaits. # this profile has no friends
```

each profile needs a keypair, right?

```
vetchricore.exe profile show
> You are using main.
vetchricore.exe key gen
> Public key: VLD0:123
> Private key: this value is hidden
vetchricore.exe key show
> Public key: VLD0:123
> Private key: this value is hidden
vetchricore.exe key show --reveal
> Public key: VLD0:123
> Private key: VLD0:567
vetchricore.exe key remove
> Are you sure? y/N: y
> Are you sure you're sure? Type "Yes, I'm sure." to proceed: Yes, I'm sure.
> Key has been removed.
vetchricore.exe key show
> You have no key. Would you like to create one? Y/n: y
> Public key: VLD0:123
> Private key: this value is hidden
```

and for the main chat demonstration, we must actually have a chat setup.
To keep the anonymization, we as a receiver must construct a private route and publish it for friends to talk to us.
Thus we will create a private route and store it in the DHT and the record key of that DHT entry is what we will share with friends.


```
vetchricore.exe profile use profile1
vetchricore.exe route create --listen
> Created route information and stored it under record key VLD:890 for profile1
> Listening for messages.
```

```
vetchricore.exe route add --friend jeff --record-key VLD:890 --profile profile2
> Added a route to jeff for profile2.
vetchricore.exe send chat to jeff --profile profile2
> Trying route record key 1 of 3.
> Acquired route information.
> CHAT> hi
> CHAT> ttyl
> Ctrl+C detected.
vetchricore.exe send chat to jeff --profile profile2 --message "beans!"
> Trying route record key 1 of 3.
> Trying route record key 2 of 3.
> Acquired route information.
> Message sent.
```

where the listening client would have the callback set up to listen for messages on that route and would print them.
It would be good to print the friend name for the public key of incoming messages.

Note the differences between our setup here vs something like email or messenger/discord.
In our setup, each profile stores record keys where a friend will publish their route information when listening, and the person will empty the record when not listening.

To send a message, we read the record to establish the route and then we send app messages that the receiving person's veilid callback will print for them.

If the other person is not "online" (record key populated) then we won't have a route to send them messages to.

There is no "conversations" where each pair of people has a chatroom to organize messages at this time, it's just sending messages and receiving. The receiving person while listening just prints the messages and may receive messages from multiple people if that route is being sent messages by multiple people.
